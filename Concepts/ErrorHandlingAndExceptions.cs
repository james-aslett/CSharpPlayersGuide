//ERROR HANDLING AND EXCEPTIONS

//SPEEDRUN
//Exceptions are C#'s primary error handling mechanism
//Exceptions are objects of the Exception type (or a derived type)
//Put code that may throw exceptions in a try block, and place handlers in catch blocks: try { Something(); } catch (SomeTypeOfException e) { HandleError(); }
//Throw a new exception with the throw keyword: throw new Exception();
//A finally block identifies code that runs regardless of how the try block exits - exception, early return, or executing to completion: try { ... } finally { ... }
//This level contains several guidelines for throwing and catch exceptions

//We have been pretending nothing will ever go wrong in our programs, and it is time to face reality. What should we do when things go wrong? Consider this code that gets a number from the user between 1 and 10:
int GetNumberFromUser()
{
    int number = 0;

    while (number < 1 || number > 10)
    {
        Console.Write("Enter a number between 1 and 10: ");
        string? response = Console.ReadLine();
        number = Convert.ToInt32(response);
    }

    return number;
}

//What happens if they enter "asdf"? Convert.ToInt32 cannot convert this, and our program unravels. Under real-life circumstances, our program crashes and terminates. If you are running in VS with a debugger, the debugger is smart enough to recognize that a crash is imminent and pause the program for you to inspect its state in its death throes.

//In C#, when a piece of code recognizes it has encountered a dead end and cannot continue, a kind of error called an exception can be generated by the code that detects it. Exceptions bubble up from a method to its caller and then to that method's caller, looking to see if anything knows how to resolve the problem so that the program can keep running. This process of transferring control father up the call stack is called throwing the exception. Parts of your code that react to a thrown exception are exception handlers. Or you could say that the exception handler catches the exception to stop it from continuing further.

//HANDLING EXCEPTIONS
//Most of our code can account for all scenarios without the potential for failures, for example  Math.Sqrt can safely handle all square roots (though it does produce the value double.NaN for negative numbers). This is the ideal situation to be in. Success is guaranteed.

//On the other hand, Convert.ToInt32 makes no such guarantee. When called with "asdf", we encounter the problem. The text cannot be converted, and the method cannot proceed with its stated job. Our approach for dealing with such errors has previously boiled down to, "Dear user: Please don't do the dumb. I can't handle it when you do the dumb." Then cross your fingers, put on your lucky socks, and grab your Minecraft Luck of the Sea enchantment.

//Rathing than hoping, let's deal with the issue head-on. We must first recognize that a code section might fail and also have a plan to recover. The problem code is placed in a try block, immediately followed by a handler for the exception:
try
{
    number = Convert.ToInt32(response);
}
catch (Exception)
{
    number = -1;
    Console.WriteLine($"I do not understand '{response}'.");
}

//The catch block will catch any exception that arises from within the try block, and the code contained there will run so that you can recover from the problem. In this case, if we fail to convert to a int for any reason, we will display the text "I do not understand..." and set number to -1.

//Let's get more specific. When code detects a failure condition - something exceptional or outside the ordinary or expected - that code creates a new instance of the class System.Exception (or something derived from Exception). This exception object represents the problem that occurred, and different derived classes represent specific categories of errors. This exception object is then thrown, which begins the process of looking for a handler further up the call stack. With the code above, Convert.ToInt32 contains the code that detects this error, creates the exception, and throws it. We will soon see how to do that ourselves.

//The program will first look in the Convert.ToInt32 method for an appropriate catch block that handles this error. It does not exist, so the search continues to the calling method, which is our code. If our code did not have a catch block that could handle the issue, the search would continue even further upward until an appropriate catch block handler is found or it escapes the program's entry point, in which case, the program would end in a crash.

//Fortunately, this code now handles such errors, so the search ends at our catch block.

//Once the code within the catch block runs, execution will resume after the try/catch block.

//If a try block has many statements and the first throws an exception, the rest of the code will not run. It is cruicial to pick the right section of code to place in your try blocks, but smaller is usually better.

//HANDLING SPECIFIC EXCEPTION TYPES
//Our catch block above handles all possile exception types. That's not usually what you want. It is generally better to be more specific about the kind of error. Handle only the types you can recover from and handle different error types differently.

//If we look at the documentation for Convert.ToInt32(string), we see that it might throw a System.FormatException or a System.OverflowException. The FormatException class occurs when the text is not numeric, and OverflowException occurs when the number is too big to store in an int. It makes sense to handle these errors in different ways. We can modify our catch block into the following:
try
{
    number = Convert.ToInt32(response);
}
catch (FormatException)
{
    number = -1;
    Console.WriteLine($"I do not understand '{response}'.");
}
catch (OverflowException)
{
    number = -1;
    Console.WriteLine($"That number is too big!");
}

//This code defines two separate catch blocks associated with a single try block, one for each of the ways Convert.ToInt32 can fail. Doing so allows us to treat each error type differently.

//When looking for an exception handler, the order matters. FormatException and OverflowException are distinct exception types, but consider this code:
try { ... }
catch (FormatException) { ... }
catch (Exception) { ... }

//The first block will handle a FormatException because it comes first. The second one will handle every other exception type because everything is derived from Exception.

//A try/catch block does not need to handle every imaginable exception type. We could simply do the following if we wanted to:
try { ... }
catch (FormatException) { ... }

//This will catch FormatException objects but leave other errors for something else to address. Code that cannot reasonably resolve a specific problem type should not catch it.

//USING THE EXCEPTION OBJECT
//An exception handler can use the expression object in its body if it needs to. To do so, add a name after the exception type in the catch's parentheses:
try { ... }
catch (FormatException e)
{
    Console.WriteLine(e.Message);
}

//The Exception class defines a Message property, so all exception object have it. Other exception types may add additional data that can be helpful, though neither FormatException nor OverflowException does this.

//THROWING EXCEPTIONS
//Let's now look at the other side of the equation: creating and throwing new exceptions.

//The first thing your code must do is recognize a problem. You will have to determine for yourself what counts as an unresolvable error in your code. But once you have detected such a situation, you are ready to create and throw an exception.

//Exceptions are represented by any object whose class is Exception or a derived class. Creating an exception object is like making any other object: you use new and invoke one of its constructors. Once created, the next step is to throw the exception, which begins the process of finding a handler for it. These are often done in a single statement:
throw new Exception();

//The new Exception() part creates the exception object. The throw keyword is the thing that initiates the hunt up the call stack for a handler. In context, this could look something like this:
Console.WriteLine("Name an animal.");
string? animal = Console.ReadLine();
if (animal == "Snake") throw new Exception(); // Why did it have to be snakes?