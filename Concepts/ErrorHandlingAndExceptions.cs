//ERROR HANDLING AND EXCEPTIONS

//SPEEDRUN
//Exceptions are C#'s primary error handling mechanism
//Exceptions are objects of the Exception type (or a derived type)
//Put code that may throw exceptions in a try block, and place handlers in catch blocks: try { Something(); } catch (SomeTypeOfException e) { HandleError(); }
//Throw a new exception with the throw keyword: throw new Exception();
//A finally block identifies code that runs regardless of how the try block exits - exception, early return, or executing to completion: try { ... } finally { ... }
//This level contains several guidelines for throwing and catch exceptions

//We have been pretending nothing will ever go wrong in our programs, and it is time to face reality. What should we do when things go wrong? Consider this code that gets a number from the user between 1 and 10:
using System.Linq.Expressions;

int GetNumberFromUser()
{
    int number = 0;

    while (number < 1 || number > 10)
    {
        Console.Write("Enter a number between 1 and 10: ");
        string? response = Console.ReadLine();
        number = Convert.ToInt32(response);
    }

    return number;
}

//What happens if they enter "asdf"? Convert.ToInt32 cannot convert this, and our program unravels. Under real-life circumstances, our program crashes and terminates. If you are running in VS with a debugger, the debugger is smart enough to recognize that a crash is imminent and pause the program for you to inspect its state in its death throes.

//In C#, when a piece of code recognizes it has encountered a dead end and cannot continue, a kind of error called an exception can be generated by the code that detects it. Exceptions bubble up from a method to its caller and then to that method's caller, looking to see if anything knows how to resolve the problem so that the program can keep running. This process of transferring control father up the call stack is called throwing the exception. Parts of your code that react to a thrown exception are exception handlers. Or you could say that the exception handler catches the exception to stop it from continuing further.

//HANDLING EXCEPTIONS
//Most of our code can account for all scenarios without the potential for failures, for example  Math.Sqrt can safely handle all square roots (though it does produce the value double.NaN for negative numbers). This is the ideal situation to be in. Success is guaranteed.

//On the other hand, Convert.ToInt32 makes no such guarantee. When called with "asdf", we encounter the problem. The text cannot be converted, and the method cannot proceed with its stated job. Our approach for dealing with such errors has previously boiled down to, "Dear user: Please don't do the dumb. I can't handle it when you do the dumb." Then cross your fingers, put on your lucky socks, and grab your Minecraft Luck of the Sea enchantment.

//Rathing than hoping, let's deal with the issue head-on. We must first recognize that a code section might fail and also have a plan to recover. The problem code is placed in a try block, immediately followed by a handler for the exception:
try
{
    number = Convert.ToInt32(response);
}
catch (Exception)
{
    number = -1;
    Console.WriteLine($"I do not understand '{response}'.");
}

//The catch block will catch any exception that arises from within the try block, and the code contained there will run so that you can recover from the problem. In this case, if we fail to convert to a int for any reason, we will display the text "I do not understand..." and set number to -1.

//Let's get more specific. When code detects a failure condition - something exceptional or outside the ordinary or expected - that code creates a new instance of the class System.Exception (or something derived from Exception). This exception object represents the problem that occurred, and different derived classes represent specific categories of errors. This exception object is then thrown, which begins the process of looking for a handler further up the call stack. With the code above, Convert.ToInt32 contains the code that detects this error, creates the exception, and throws it. We will soon see how to do that ourselves.

//The program will first look in the Convert.ToInt32 method for an appropriate catch block that handles this error. It does not exist, so the search continues to the calling method, which is our code. If our code did not have a catch block that could handle the issue, the search would continue even further upward until an appropriate catch block handler is found or it escapes the program's entry point, in which case, the program would end in a crash.

//Fortunately, this code now handles such errors, so the search ends at our catch block.

//Once the code within the catch block runs, execution will resume after the try/catch block.

//If a try block has many statements and the first throws an exception, the rest of the code will not run. It is cruicial to pick the right section of code to place in your try blocks, but smaller is usually better.

//HANDLING SPECIFIC EXCEPTION TYPES
//Our catch block above handles all possile exception types. That's not usually what you want. It is generally better to be more specific about the kind of error. Handle only the types you can recover from and handle different error types differently.

//If we look at the documentation for Convert.ToInt32(string), we see that it might throw a System.FormatException or a System.OverflowException. The FormatException class occurs when the text is not numeric, and OverflowException occurs when the number is too big to store in an int. It makes sense to handle these errors in different ways. We can modify our catch block into the following:
try
{
    number = Convert.ToInt32(response);
}
catch (FormatException)
{
    number = -1;
    Console.WriteLine($"I do not understand '{response}'.");
}
catch (OverflowException)
{
    number = -1;
    Console.WriteLine($"That number is too big!");
}

//This code defines two separate catch blocks associated with a single try block, one for each of the ways Convert.ToInt32 can fail. Doing so allows us to treat each error type differently.

//When looking for an exception handler, the order matters. FormatException and OverflowException are distinct exception types, but consider this code:
try { ... }
catch (FormatException) { ... }
catch (Exception) { ... }

//The first block will handle a FormatException because it comes first. The second one will handle every other exception type because everything is derived from Exception.

//A try/catch block does not need to handle every imaginable exception type. We could simply do the following if we wanted to:
try { ... }
catch (FormatException) { ... }

//This will catch FormatException objects but leave other errors for something else to address. Code that cannot reasonably resolve a specific problem type should not catch it.

//USING THE EXCEPTION OBJECT
//An exception handler can use the expression object in its body if it needs to. To do so, add a name after the exception type in the catch's parentheses:
try { ... }
catch (FormatException e)
{
    Console.WriteLine(e.Message);
}

//The Exception class defines a Message property, so all exception object have it. Other exception types may add additional data that can be helpful, though neither FormatException nor OverflowException does this.

//THROWING EXCEPTIONS
//Let's now look at the other side of the equation: creating and throwing new exceptions.

//The first thing your code must do is recognize a problem. You will have to determine for yourself what counts as an unresolvable error in your code. But once you have detected such a situation, you are ready to create and throw an exception.

//Exceptions are represented by any object whose class is Exception or a derived class. Creating an exception object is like making any other object: you use new and invoke one of its constructors. Once created, the next step is to throw the exception, which begins the process of finding a handler for it. These are often done in a single statement:
throw new Exception();

//The new Exception() part creates the exception object. The throw keyword is the thing that initiates the hunt up the call stack for a handler. In context, this could look something like this:
Console.WriteLine("Name an animal.");
string? animal = Console.ReadLine();
if (animal == "Snake") throw new Exception(); // Why did it have to be snakes?

//The Exception class represents the most generic error in existence. With this code, all we know is that something went wrong. In general, you want to throw instances of a class derived from Exception, not Exception itself. Doing so allows us to convey what went wrong more accurately and enables handlers to be more specific about if and how to handle it.

//There is a mountain of existing exception types that you can pick from, which represent various situations. Here are a few of the more common ones, along with their meanings.

//NotImplementedException - "The programmer hasn't written this code yet."
//NotSupportedException - "I will never be able to do this."
//InvalidOperationException - "I can't do this in my current state, but I might be able to in another state."
//ArgumentOutOfRangeExcpetion - "This argument was too big (too small, etc.) for me to use."
//ArgumentNullException - "This argument was null, and I can't work with a null value."
//ArgumentException - "Something is wrong with one of your arguments."
//Exception - "Something went wrong, but I don't have any real info about it."

//Rather than using new Exception() earlier, we should have picked a more specific type. Perhaps NotSupportedException is a better choice:
Console.WriteLine("Name an animal");
string? animal = Console.ReadLine();
if (animal == "snake") throw NotSupportedException();

//Most exception types also allow you to supply a message as a parameter, and it is often helpful to include one to help programmers who encounter it later:
if (animal == "snake") throw new NotSupportedException("I have ophidiophobia");

//Depending on the exception type, you might be able (or even required) to supply additional information to the constructor.

//If one of the existing exception types isn't sufficient to categorize an error, make your own by defining a new class derived from Exception or another exception class:
public class SnakeException : Exception
{
    public SnakeException() { }
    public SnakeException(string message) : base(message) { }
}

//Always use a meaningful exception type when you throw exceptions. Avoid throwing plan old Exception. Use an existing type if it makes sense. Otherwise, create a new one.

//THE FINALLY BLOCK
//A finally block is often used in conjunction with try and catch. A finally block conStains code that should run regardless of how the flow of execution leaves a try block, whether that is by typical completion of the code, throwing an exception, or an early return:
try
{
    Console.WriteLine("Shall we play a game?");
    if (Console.ReadLine() == "no") return;

    Console.WriteLine("Name an animal.");
    string? animal = Console.ReadLine();
    if (animal == "snake") throw new SnakeException();
}
catch (SnakeException) { Console.WriteLine("Why did it have to be snakes?");  }
finally
{
    Console.WriteLine("We're all done here.");
}

//There are three ways to exit the try block above; the finally block runs in all of them. If the early return on line 4 is encountered, the finally block executes before returning. If the end of the try block is reached through normal execution, the finally block is executed. If a SnakeException is thrown, the finally block executes after the SnakeException handler runs. If this code threw a different exception not handled here, the finally block still runs before leaving the method to find a handler.

//The purpose of a finally block is to perform cleanup reliably. You know it will always run, so it is a good place to put code that ensures things are left in a good state before moving on. As such, it is not uncommon to have just a try and a finally with no catch blocks at all.

//EXCEPTION GUIDELINES
//Let's look at some guidelines for throwing and catching exceptions.

//What to Handle
//Any exception that goes unhandled will crash the program. In general, this means you should have a bias for catching exceptions instead of letting them go. But exception handling code is more complicated that than code that does not. Code understandability is also valuable.

//Catching exceptions is especially important in products where failure means loss of human life or injury versus a low-stakes utility that will almost always be used correctly. In the low-stakes, low-risk programs, skipping some or all the exception handling could be an acceptable choice. Every program we have made so far could arguably fit into this category.

//Still, handling exceptions allows a program to deal with strageness and surprises. Code that does this is robust. Even if nobody dies from a software crash, your users will appreciate it being robust. With exception handling knowledge, you should have a bias for doing it, not skipping it.

//Only Handle What You Can Fix
//If an exception handler cannot resolve the problem represented by the exception, the handler should not exist. Instead, the exception should be allowed to continue up the call stack, hoping that something farther up has meaningful resolution steps for the problem. This is a counterpoint to the previous item. If there is no recourse for an error, it is resonable for the program to end.

//There are some allowances here. Sometimes, a handler will repair or address what it can (even just logging the problem) while still allowing the exception to continue (described later).

//Use the Right Exception Type
//An exception's type (class) is the simplest way to differentiate one error category from another. By picking the right exception type when throwing exception (making your own if needed), you make life easier when handling exceptions.

//Avoid Pokemon Exception Handling
//Sometimes, it is tempting to handle any possible error in the same way with this:
catch (Exception) { Console.WriteLine("Something went wrong."); }

//Some programmers calls this Pokemon exception handling. Using catch (Exception) catches every possible exception with no... um... exceptions. It is reminiscent of the catchphrase from the game Pokemon, "Gotta catch 'em all!"

//The problem with treating everything the same is that it is often too generic. "Something went wrong" is an awful error message. Whether solved by humans or code, an error's recourse is rarely the same for all possible errors.

//There are, of course, times where this is the only thing that makes sense. Some people will put a catch (Exception) block around their entire program to catch any stray unhandled exceptions as the program is dying to produce an error report or something similar. But letting the program attempt to resume is often dangerous because we have no guarantees about the program's state when the exception occured. So use Pokemon exception handling sparingly, and in general, let the program die afterward.

//Avoid Eating Exceptions
//A catch block that looks like this is usually bad:
catch (SomeExceptionType) { }

//An empty handler like this is referred to as 'eating the exception', 'swallowing the error', or 'failing silently'. Correct exception handling rarely requires doing nothing at all. Empty catch blocks nearly always represent a programmer who got lazy.

//The problem is that an error occured, and no response was taken to address it. It may leave the program in a weird or inconsistent state - one in which the program should not be running.

//Eating exceptions is especially bad when combined with the previous item: catch (Exception) { }. Here, every single error is caught and thrown right into the garbage chute.
